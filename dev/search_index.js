var documenterSearchIndex = {"docs":
[{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"EditURL = \"https://github.com/tkf/Reagents.jl/blob/master/examples/nack.jl\"","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"note: Note\nReagents.jl is still work-in-progress.","category":"page"},{"location":"tutorials/nack/#nack","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"","category":"section"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"using Reagents\nusing Reagents: WithNack, Return\nusing Test","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Reagents.jl provides so-called negative acknowledgement (NACK) reagent Reagents.WithNack which is taken from Concurrent ML.  This is useful for writing \"client-server\" style of code where the client can abort the request.","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"note: Note\nConcurrent ML provides composable synchronizable operations called events which are similar to Reagent.  Turon (2012) discussed influences of Concurrent ML on reagents.See also:Concurrent ML's manual on withNack\nRacket's manual on nack-guard-evt","category":"page"},{"location":"tutorials/nack/#How-it-works","page":"Negative acknowledgement (NACK)","title":"How it works","text":"","category":"section"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Let us set up a demo.","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"function nack_demo()","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Reagents.WithNack has non-trivial effect only when used inside the choice combinator which possibly blocking branches.  Thus, to selectively trigger two branches in the choice combinator, we create two channels:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    s1, r1 = Reagents.channel()\n    s2, r2 = Reagents.channel()","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"To receive the negative acknowledgement, we craete one more channel:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    send_gotnack, receive_gotnack = Reagents.channel()","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"The first branch br1 (below) uses Reagents.WithNack.  It passes the negative acknowledgement reagent nack to the user-defined function (the do block; it returns a reagent).  The reagent nack blocks until this branch br1 is cancelled (i.e., another branch of | is chosen).","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    br1 = WithNack() do nack\n        @async (nack ⨟ Return(:gotnack) ⨟ send_gotnack)()\n        return r1\n    end","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"We just use a channel endpoint for another branch:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    br2 = r2","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"These two reagents are composed with the choice combinator |:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    choice = br1 | br2","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Returning the reagents so that they can be invoked differently for trying differnt scenarios:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    return (; choice, s1, s2, receive_gotnack)\nend","category":"page"},{"location":"tutorials/nack/#Scenario-1:-nack-is-triggered","page":"Negative acknowledgement (NACK)","title":"Scenario 1: nack is triggered","text":"","category":"section"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"function test_nack_demo_1()\n    (; choice, s2, receive_gotnack) = nack_demo()\n    @sync begin","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Let us choose the second branch br2 which does not include WithNack:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"        @async s2(222)\n        @test choice() == 222\n    end","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Since the branch br1 with WithNack is not chosen, we get the negative acknowledgement:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    @test receive_gotnack() == :gotnack\nend","category":"page"},{"location":"tutorials/nack/#Scenario-2:-nack-is-not-triggered","page":"Negative acknowledgement (NACK)","title":"Scenario 2: nack is not triggered","text":"","category":"section"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"function test_nack_demo_2()\n    (; choice, s1, receive_gotnack) = nack_demo()\n    @sync begin","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"This time, we choose the first branch br1 which includes WithNack:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"        @async s1(111)\n        @test choice() == 111\n    end","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Since we chose the WithNack's branch, nack is not triggered this time:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    @test Reagents.try(receive_gotnack) === nothing\nend","category":"page"},{"location":"tutorials/nack/#Client-server-pattern","page":"Negative acknowledgement (NACK)","title":"Client-server pattern","text":"","category":"section"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"WithNack is useful for writing \"client-server\" pattern. As an example, we'll create an in-process \"server\" that issues unique IDs. That is to say, we'd like to have the following API:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"function test_unique_id_provider_api()\n    with_unique_id_provider() do unique_id\n        @test unique_id() == 0\n        @test unique_id() == 1\n    end\nend","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Here, unique_id is a reagent for communicating with a server created in with_unique_id_provider.","category":"page"},{"location":"tutorials/nack/#unique_id_provider!","page":"Negative acknowledgement (NACK)","title":"unique_id_provider!","text":"","category":"section"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Let us start from the event loop of the server.  The server listens to ID requests from request_receive and a shutdown request from shutdown_receive.","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"function unique_id_provider!(request_receive, shutdown_receive)","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"It keeps the current available ID as its local variable:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    id = 0\n    while true","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"First, the server listens to both request_receive and shutdown_receive. The latter returns nothing upon shutdown request.","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"        receive_request_or_shutdown = request_receive | shutdown_receive","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"When the shutdown_receive reagent is chosen (i.e., the reaction result is nothing), the short-circuting @something evaluates the break statement so that the server exits the loop:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"        (; reply, abort) = @something(receive_request_or_shutdown(), break)","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"The client (see below) sends reply and abort channel endpoints.  The server tries to send the ID with Return(id) ⨟ reply while also listening to the abort (NACK) and shutdown requests:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"        try_reply = (\n            (Return(id) ⨟ reply ⨟ Return(true)) |  # try sending the id\n            (abort ⨟ Return(false)) |              # or wait for the abort (NACK)\n            shutdown_receive                       # or wait for shutdown\n        )","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"The server only increments the ID when the client received the ID.","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"        if @something(try_reply(), break)\n            id += 1\n        end\n    end  # while true\nend  # function unique_id_provider!","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"(For an ID server, this property is probably not required. But consider, e.g., a lock server, where it is important to know that the client received the reply.)","category":"page"},{"location":"tutorials/nack/#with_unique_id_provider","page":"Negative acknowledgement (NACK)","title":"with_unique_id_provider","text":"","category":"section"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"The channels connecting the server and client are set up in the function below. The client API can be invoked inside the function f passed as the argument:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"function with_unique_id_provider(f)\n    request_send, request_receive = Reagents.channel()\n    shutdown_send, shutdown_receive = Reagents.channel(Nothing)","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"For each request, the client creates the channel (reply) for receiving the ID and also the negative acknowledgement reaagent abort for communicating that the request is aborted:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    unique_id = WithNack() do abort\n        reply, receive = Reagents.channel(Int, Nothing)\n        request_send((; reply, abort))\n        return receive\n    end","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Finally, we start the server in a task and execute the client's code f:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"    @sync begin\n        @async unique_id_provider!(request_receive, shutdown_receive)\n        try\n            f(unique_id)\n        finally\n            shutdown_send()\n        end\n    end\nend","category":"page"},{"location":"tutorials/nack/#Testing-the-ID-server","page":"Negative acknowledgement (NACK)","title":"Testing the ID server","text":"","category":"section"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"function test_unique_id_provider()\n    with_unique_id_provider() do unique_id","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"When used alone, unique_id simply sends a request and wait for a reply from the ID server:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"        @test unique_id() == 0\n        @test unique_id() == 1","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Demonstrating the behavior of aborting the request is a bit more involved. First, we create a task that tries to send the \"cancellation\" request via a channel:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"        send, receive = Reagents.channel(Nothing)\n        canceller = @task send()\n        yield(canceller)","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Since we don't know when send() will be invoked, we'll try it in a loop. The variable prev keeps track of the last id issued by the server:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"        prev = unique_id()\n        while true","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Then invoke unique_id and receive together. If this reaction takes choose the branch of receive (\"cancellation\"), it returns a nothing:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"            ans = (unique_id | receive)()\n            if ans === nothing","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"Here, we have attempted to invoke the unique_id reagent but it was aborted by another reagent receive.  Since this triggers the nack reagent abort, this reaction did not update the server's state (the variable id). So, the next call to unique_id should increment the ID only by one:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"                @test unique_id() == prev + 1\n                break","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"If receive was not tirggered, we keep the id ans so that it can be used in the next iteration:","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"            else\n                prev = ans::Int\n            end\n        end\n    end\nend","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"","category":"page"},{"location":"tutorials/nack/","page":"Negative acknowledgement (NACK)","title":"Negative acknowledgement (NACK)","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"EditURL = \"https://github.com/tkf/Reagents.jl/blob/master/examples/locks.jl\"","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"note: Note\nReagents.jl is still work-in-progress.","category":"page"},{"location":"tutorials/locks/#Locks","page":"Locks","title":"Locks","text":"","category":"section"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"We can quite easily implement various locks based on the Blocking containers we have implemented.","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"include(\"cancellablecontainers.jl\")\nusing Reagents: PostCommit, dissolve\n\nusing ArgCheck: @argcheck","category":"page"},{"location":"tutorials/locks/#Simple-lock","page":"Locks","title":"Simple lock","text":"","category":"section"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"A simple (non-reentrant) lock can be created as a simple wrapper of a blocking container (e.g., a stack):","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"struct SimpleLock <: Base.AbstractLock\n    access::typeof(Blocking(TreiberStack{Nothing}()))\nend","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"A lock is acquired by emptying the container so that subsequent attempts to acquire the lock will block until the element is put back into the container:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"acquiring(l::SimpleLock) = taking(l.access)\nrealeasing(l::SimpleLock) = Return(nothing) ⨟ putting(l.access)\n\nBase.lock(l::SimpleLock) = acquiring(l)()\nBase.unlock(l::SimpleLock) = realeasing(l)()","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Thus, when creating a lock with an empty container, it is in the locked state. We need to unlock it (i.e., put one element in the container) before start using the lock:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"function SimpleLock()\n    l = SimpleLock(Blocking(TreiberStack{Nothing}()))\n    unlock(l)  # start with unlocked state\n    return l\nend","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Here's how it works:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"function test_simplelock()\n    l = SimpleLock()\n    send, receive = Reagents.channel()\n    @sync begin\n        child_locked = Threads.Atomic{Bool}(false)\n        child_unlocked = Threads.Atomic{Bool}(false)\n        lock(l) do","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"While the lock is acquired, the child task cannot lock it:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"            Threads.@spawn begin\n                send(:child_started)\n                lock(l) do\n                    child_locked[] = true\n                    send(:child_locked)\n                end\n                child_unlocked[] = true\n                send(:child_unlocked)\n            end\n            @test receive() === :child_started\n            @test !child_locked[]\n        end  # lock(l) do","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"After unlocking the lock in the parent task, the child task can acquire the lock:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"        @test receive() === :child_locked\n        @test child_locked[]\n        @test receive() === :child_unlocked\n        @test child_unlocked[]\n    end\nend","category":"page"},{"location":"tutorials/locks/#Locking-with-a-timeout","page":"Locks","title":"Locking with a timeout","text":"","category":"section"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Since SimpleLock exposes the reagent API, it can be composed with other reagents. For example, it is straightforward to add timeout to the lock:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"function timeout(seconds::Real)\n    send, receive = Reagents.channel(Nothing)\n    @async begin\n        sleep(seconds)\n        send(nothing)\n    end\n    return receive\nend\n\nfunction try_with_timeout(reagent, seconds::Real)\n    reagent = (reagent ⨟ Map(Some)) | timeout(seconds)\n    return reagent()\nend","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Calling try_with_timeout(reagent, seconds) execute reagent with the timeout seconds. It returns nothing on timeout. If reagent completes its reaction with the output value, try_with_timeout returns Some(value). It can be used with arbitrary reagent, including acquiring(::SimpleLock):","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"function test_simplelock_timeout()\n    l = SimpleLock()","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"If the lock is not acquired already, adding timeout does nothing:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"    a1 = try_with_timeout(acquiring(l), 0.1)\n    @test a1 isa Some  # successfully acquire","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"If the lock is already acquired, try_with_timeout will fail after the timeout:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"    a2 = fetch(@async try_with_timeout(acquiring(l), 0.1))\n    @test a2 === nothing  # failed to acquire\nend","category":"page"},{"location":"tutorials/locks/#Trying-to-acquire-multiple-locks","page":"Locks","title":"Trying to acquire multiple locks","text":"","category":"section"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"SimpleLock can also be composed with itself. For example, we can use the choice combinator | to acquire an available lock:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"function test_simplelock_multiple()\n    l1 = SimpleLock()\n    l2 = SimpleLock()","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Let us lock l1 first, so that subsequent lock cannot acquire it:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"    lock(l1) do\n        local ans\n        @sync begin\n            Threads.@spawn begin","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Since we need to change the action depending on which lock is acquired (importantly, which one to unlock), we use Reagents.Return to associate different returned value for each branch of the | combinator:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"                ans = (\n                    (acquiring(l1) ⨟ Return(1)) |  # try lock l1; will fail\n                    (acquiring(l2) ⨟ Return(2))    # try lock l2; will succeeds\n                )()","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Since l1 is already acquired, we should have ans == 2 here (checked below). But first, let's unlock the corresponding lock:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"                if ans == 1  # unreachable, but demonstrating the generic usage\n                    unlock(l1)\n                elseif ans == 2\n                    unlock(l2)\n                end\n            end\n        end","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"As mentioned above, we expect that l2 was acquired in the child task:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"        @test ans == 2\n    end\nend","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Remembering which lock to unlock is rather cumbersome. Let us wrap it in an interface that can be used with the do-block syntax:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"function lockany(f, pairs...)\n    acquired, value = mapfoldl(lv -> acquiring(first(lv)) ⨟ Return(lv), |, pairs)()\n    try\n        f(value)\n    finally\n        unlock(acquired)\n    end\nend","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"The above code can now be expressed more succinctly:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"function test_simplelock_lockany()\n    l1 = SimpleLock()\n    l2 = SimpleLock()\n    local ans\n    lock(l1) do\n        @sync begin\n            Threads.@spawn begin\n                lockany(l1 => 1, l2 => 2) do x\n                    ans = x\n                end\n            end\n        end\n    end\n    @test ans == 2\nend","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Note: SimpleLock and SimpleSemaphore are inspired by Turon & Russo (2011).","category":"page"},{"location":"tutorials/locks/#Semaphore","page":"Locks","title":"Semaphore","text":"","category":"section"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"SimpleLock can be extended to a semaphore by just initially fillying more than one elements:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"struct SimpleSemaphore\n    accesses::typeof(Blocking(TreiberStack{Nothing}()))\nend\n\nfunction SimpleSemaphore(n::Integer)\n    @argcheck n > 0\n    accesses = Blocking(TreiberStack{Nothing}())\n    for _ in 1:n\n        put!(accesses, nothing)\n    end\n    return SimpleSemaphore(accesses)\nend\n\nacquiring(l::SimpleSemaphore) = taking(l.accesses)\nrealeasing(l::SimpleSemaphore) = Return(nothing) ⨟ putting(l.accesses)\n\nBase.acquire(l::SimpleSemaphore) = acquiring(l)()\nBase.release(l::SimpleSemaphore) = realeasing(l)()","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Unlike SimpleLock, we can acquire SimpleSemaphore(n) n times before blocked:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"function test_simplesemaphore()\n    sem = SimpleSemaphore(2)\n    Base.acquire(sem)\n    Base.acquire(sem)\n    t = @task Base.acquire(sem)\n    yield(t)\n    @test !istaskdone(t)\n    Base.release(sem)\n    wait(t)\nend","category":"page"},{"location":"tutorials/locks/#Reader-writer-lock","page":"Locks","title":"Reader-writer lock","text":"","category":"section"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"This example is from Turon & Russo (2011) “Scalable Join Patterns.”  As mentioned in Turon (2012), the join pattern can be expressed with catalysts.","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Their reader-writer lock is acquired and released by sending messages to a channel. Let us define a simple wrapper type to express this:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"struct ChLock <: Base.AbstractLock\n    acq::typeof(Reagents.channel(Nothing)[1])\n    rel::typeof(Reagents.channel(Nothing)[1])\nend\n\nacquiring(l::ChLock) = l.acq\nrealeasing(l::ChLock) = l.rel\n\nBase.lock(l::ChLock) = acquiring(l)()\nBase.unlock(l::ChLock) = realeasing(l)()","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"To create two kinds of locks, we create 2 * 2 = 4 channels.  The state of the lock is mantained by two blocking data structures (Note: We only need to store at most one element. So, a stack is an overkill.  But that's the most cheap data structure we have implemented so far in the tutorial):","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"function reader_writer_lock()\n    idle = Blocking(TreiberStack{Nothing}())\n    shared = Blocking(TreiberStack{Int}())\n    acqr = Reagents.channel(Nothing)\n    acqw = Reagents.channel(Nothing)\n    relr = Reagents.channel(Nothing)\n    relw = Reagents.channel(Nothing)\n    dissolve(acqr[2] ⨟ taking(idle) ⨟ PostCommit(_ -> put!(shared, 1)))\n    dissolve(acqr[2] ⨟ taking(shared) ⨟ PostCommit(n -> put!(shared, n + 1)))\n    dissolve(relr[2] ⨟ taking(shared) ⨟ PostCommit() do n\n        if n == 1\n            put!(idle, nothing)\n        else\n            put!(shared, n - 1)\n        end\n    end)\n    dissolve(acqw[2] ⨟ taking(idle))\n    dissolve(relw[2] ⨟ PostCommit(_ -> put!(idle, nothing)))\n    put!(idle, nothing)\n    return ChLock(acqr[1], relr[1]), ChLock(acqw[1], relw[1])\nend","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Observe that how the states of the lock are implemented:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"When the reader-writer lock is not acquired, idle has a single element. shared is empty.\nWhen at least one of the reader (shared) lock is acquired, the number of acquired locks are stored in the shared container. The idle container is empty.\nWhen the writer (exclusive) lock is acquired, both the shared and idle container is empty.","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"As discussed in catalysts, Reagents.dissolve is used for expressing the rules that expressing allowed transitions between these states.","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Here's how it works:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"function test_reader_writer_lock()\n    s1, r1 = Reagents.channel()\n    s2, r2 = Reagents.channel()\n    rlock, wlock = reader_writer_lock()\n    @sync begin","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Reader lock can be acquired multiple times:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"        Threads.@spawn begin\n            lock(rlock) do\n                s1(1)\n                s2(:done)\n            end\n        end\n        Threads.@spawn begin\n            lock(rlock) do\n                s1(2)\n                s2(:done)\n            end\n        end\n        @test sort!([r1(), r1()]) == [1, 2]","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"While the reader lock is aquired, the writer lock cannot be acquired:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"        wlocked = Threads.Atomic{Bool}(false)\n        Threads.@spawn begin\n            lock(wlock) do\n                wlocked[] = true\n                s1(3)\n                s2(:done)\n            end\n        end\n        for _ in 1:3\n            sleep(0.1)\n            @test !wlocked[]\n        end\n        @test r2() === r2() === :done  # releaseing `rlock`\n        @test r1() == 3\n        @test wlocked[]","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"While the writer lock is aquired, the reader lock cannot be acquired:","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"        r4locked = Threads.Atomic{Bool}(false)\n        r5locked = Threads.Atomic{Bool}(false)\n        Threads.@spawn begin\n            lock(rlock) do\n                r4locked[] = true\n                s1(4)\n                s2(:done)\n            end\n        end\n        Threads.@spawn begin\n            lock(rlock) do\n                r5locked[] = true\n                s1(5)\n                s2(:done)\n            end\n        end\n        for _ in 1:3\n            sleep(0.1)\n            @test r4locked[] == r5locked[] == false\n        end\n        @test r2() === :done  # releaseing `wlock`\n        @test sort!([r1(), r1()]) == [4, 5]\n        @test r4locked[] == r5locked[] == true\n        @test r2() === r2() === :done  # releaseing `rlock`\n    end\nend","category":"page"},{"location":"tutorials/locks/#References","page":"Locks","title":"References","text":"","category":"section"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"Turon, Aaron. “Reagents: Expressing and Composing Fine-Grained Concurrency.” In Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation, 157–168. PLDI ’12. New York, NY, USA: Association for Computing Machinery, 2012. https://doi.org/10.1145/2254064.2254084.\nTuron, Aaron J., and Claudio V. Russo. “Scalable Join Patterns.” In Proceedings of the 2011 ACM International Conference on Object Oriented Programming Systems Languages and Applications, 575–594. OOPSLA ’11. New York, NY, USA: Association for Computing Machinery, 2011. https://doi.org/10.1145/2048066.2048111.","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"","category":"page"},{"location":"tutorials/locks/","page":"Locks","title":"Locks","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"EditURL = \"https://github.com/tkf/Reagents.jl/blob/master/examples/catalysts.jl\"","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"note: Note\nReagents.jl is still work-in-progress.","category":"page"},{"location":"tutorials/catalysts/#catalysts","page":"Catalysts","title":"Catalysts","text":"","category":"section"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"A catalyst can be introduced by Reagents.dissolve for expressing a rule under which a certain set of reactions can happen.","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"As a motivating example, consider writing a program with multiple channels:","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"function test_catalyst_idea()\n    send1, receive1 = Reagents.channel(Int, Nothing)\n    send2, receive2 = Reagents.channel(Char, Nothing)\n    sendall, receiveall = Reagents.channel(Tuple{Int,Char}, Nothing)","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"Suppose we want to combine the items from the first and the second channels into the third channel.  In principle, this can be expressed as a \"background\" task repeatedly executing such reaction (\"catalyst\"):","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"    background_task = @async begin\n        catalyst = (receive1 & receive2) ⨟ sendall\n        while true\n            catalyst()\n        end\n    end","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"The above background_task transfers the items that are available in receive1 and receive2 to to sendall.","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"    @sync begin\n        @async send1(1)\n        @async send2('a')\n        @test receiveall() == (1, 'a')\n    end","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"Since the background_task keeps helping the reactions, we can invoke the same set of reactions multiple times:","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"    @sync begin\n        @async send1(2)\n        @async send2('b')\n        @test receiveall() == (2, 'b')\n    end\nend","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"(Aside: Note the use of unstructured concurrency for implementing the background_task.  The error happening inside of this task cannot be noticed at relevant locations.  This is another motivation for avoiding this style.)","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"A downside of the approach above is that it invokes many context switches between tasks. For more efficient and direct style of expressing the idea, we can use Reagents.dissolve.","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"Let us re-implement the above example:","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"function test_zip2()\n    send1, receive1 = Reagents.channel(Int, Nothing)\n    send2, receive2 = Reagents.channel(Char, Nothing)\n    sendall, receiveall = Reagents.channel(Tuple{Int,Char}, Nothing)","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"If the items are aviable in receive1 and receive2, the catalyst reagent automatically tries to pass them to sendall:","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"    catalyst = (receive1 & receive2) ⨟ sendall\n    Reagents.dissolve(catalyst)","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"Just like the background_task-based example above, the catalyst helps invoking the matched set of reactions:","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"    @sync begin\n        @async send1(1)\n        @async send2('a')\n        @test receiveall() == (1, 'a')\n    end","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"Since the catalyst will not be \"used up,\" we can invoke the same reaction multiple times:","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"    @sync begin\n        @async send1(2)\n        @async send2('b')\n        @test receiveall() == (2, 'b')\n    end\nend","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"","category":"page"},{"location":"tutorials/catalysts/","page":"Catalysts","title":"Catalysts","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"EditURL = \"https://github.com/tkf/Reagents.jl/blob/master/examples/msqueue.jl\"","category":"page"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"note: Note\nReagents.jl is still work-in-progress.","category":"page"},{"location":"tutorials/msqueue/#ex-msqueue","page":"Michael and Scott queue","title":"Example: Michael and Scott queue","text":"","category":"section"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"WIP (TODO: add explanation)","category":"page"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"https://www.cs.rochester.edu/u/scott/papers/1996PODCqueues.pdf","category":"page"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"using Reagents\n\nstruct MSQNode{T,R}\n    next::R\n    data::T\n    # Node{T,R}() = new{T,R}()\n    MSQNode{T,R}(next) where {T,R} = new{T,R}(next)\n    MSQNode{T,R}(next, data) where {T,R} = new{T,R}(next, data)\nend\n\nconst MSQNodeRef{T} = Reagents.Ref{Union{Nothing,MSQNode{T}}}\nconst MSQHeadRef{T} = Reagents.Ref{MSQNode{T}}\n\nMSQNode(next::MSQNodeRef{T}) where {T} = MSQNode{T,typeof(next)}(next)\nMSQNode(next::MSQNodeRef{T}, data) where {T} = MSQNode{T,typeof(next)}(next, data)\n\nstruct MSQueue{T,R<:MSQHeadRef{T}}\n    head::R\n    tail::R\n    function MSQueue{T}() where {T}\n        node = MSQNode(MSQNodeRef{T}(nothing))\n        head = MSQHeadRef{T}(node)\n        tail = MSQHeadRef{T}(node)\n        return new{T,typeof(head)}(head, tail)\n    end\nend\n\nnodetype(::MSQueue{<:Any,R}) where {N,R<:Reagents.Ref{N}} = N\n\nBase.eltype(::Type{<:MSQueue{T}}) where {T} = T\n\ntrypoppingfirst(q::MSQueue{T}) where {T} =\n    Reagents.Update(q.head) do node, _\n        next = node.next[]\n        if next === nothing\n            (node, nothing)\n        else\n            next::nodetype(q)\n            (next, Some(next.data))\n        end\n    end\n\npushing(q::MSQueue{T}) where {T} =\n    Reagents.Computed() do x\n        node = MSQNode(MSQNodeRef{T}(nothing), x)\n        while true\n            tail = q.tail[]\n            tail::nodetype(q)\n            next = tail.next[]\n            if next === nothing  # found the tail\n                return Reagents.CAS(tail.next, nothing, node) ⨟ Reagents.PostCommit() do _\n                    Reagents.try(Reagents.CAS(q.tail, tail, node))\n                end\n            else  # need the fixup\n                next::nodetype(q)\n                Reagents.try(Reagents.CAS(q.tail, tail, next))\n            end\n        end\n    end\n\ntrypopfirst!(q::MSQueue) = trypoppingfirst(q)()\nBase.popfirst!(q::MSQueue) = something(trypopfirst!(q))\nBase.push!(q::MSQueue, x) = pushing(q)(convert(eltype(q), x))","category":"page"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"","category":"page"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"EditURL = \"https://github.com/tkf/Reagents.jl/blob/master/examples/treiberstack.jl\"","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"note: Note\nReagents.jl is still work-in-progress.","category":"page"},{"location":"tutorials/treiberstack/#ex-treiberstack","page":"Treiber stack","title":"Example: Treiber stack","text":"","category":"section"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"using Reagents","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Treiber stack is a simple concurrent data structure where an immutable list holds the data items","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"struct TSNode{T}\n    head::T\n    tail::Union{TSNode{T},Nothing}\nend\n\nconst TSList{T} = Union{TSNode{T},Nothing}","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"... which is referenced through an atomically updatable memory location (here, a Reagents.Ref):","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"struct TreiberStack{T,Ref<:Reagents.Ref{TSList{T}}}\n    head::Ref\nend\n\nBase.eltype(::Type{<:TreiberStack{T}}) where {T} = T","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"An empty stack can be constructed as a reference to the empty list; i.e., nothing:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"TreiberStack{T}() where {T} = TreiberStack(Reagents.Ref{TSList{T}}(nothing))","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"To push an element to the stack, we can use Reagents.Update","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"pushing(stack::TreiberStack) =\n    Reagents.Update((xs, x) -> (TSNode(x, xs), nothing), stack.head)","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Let's see how it works.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"using Test\n\nfunction test_pushing()","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"When a stack is created, its head points to nothing:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    stack = TreiberStack{Int}()\n    @test stack.head[] === nothing  # empty","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"We can create a reagent for pushing a value to the stack:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    reagent = pushing(stack)","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"However, note that reagent does nothing when it's created.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    @test stack.head[] === nothing  # empty","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"The reagent must be executed (\"react\") to invoke its side-effect:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    reagent(111)\n    @test stack.head[] === TSNode(111, nothing)\nend","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Similarly, we can pop off an element from the stack, again by Reagents.Update. To support empty stack, we return nothing when it's empty and return Some(value) when we find a value:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"trypopping(stack::TreiberStack) =\n    Reagents.Update(stack.head) do xs, _ignored\n        if xs === nothing\n            return (nothing, nothing)\n        else\n            return (xs.tail, Some(xs.head))\n        end\n    end","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Here's how it works.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"function test_trypopping()","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Let's push 111 and then 222 using the pushing reagent:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    stack = TreiberStack{Int}()\n    pushing(stack)(111)\n    pushing(stack)(222)","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"We can invoke the reagent trypopping(stack) by calling it. Since trypopping ignores the input (see the argument _ignored in trypopping definition above), we can pass an arbitrary value to the reagent, e.g., nothing.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    @test trypopping(stack)(nothing) === Some(222)","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"For convinience, nothing is the default argument when the reagent is called without an argument:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    @test trypopping(stack)() === Some(111)","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Now that all values are popped, invoking trypopping returns nothing:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    @test trypopping(stack)() === nothing\nend","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"It is simple to wrap these reagents into the Base API:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Base.push!(stack::TreiberStack, value) = pushing(stack)(convert(eltype(stack), value))\nBase.pop!(stack::TreiberStack) = something(trypopping(stack)())","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Note that this version of pop!(stack::TreiberStack) throws when the stack is empty.  See Blocking containers for a generic derivation of a blocking version of pop! that waits for the value to be push!ed.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"For more usage examples, see /test/ReagentsTests/src/test_treiberstack.jl.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"Main._BANNER_","category":"page"},{"location":"reference/api/","page":"API","title":"API","text":"","category":"page"},{"location":"reference/api/#Reagents","page":"API","title":"Reagents","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"Reagents.Reagent","category":"page"},{"location":"reference/api/#Reagents.Reagent","page":"API","title":"Reagents.Reagent","text":"Reagents.Reagent\n\nComposable description for nonblocking and synchronous operations.\n\nReagents can be composed with ∘ although it is recommended to use the opposite composition operator ⨟.  A composed Reagent can be called, just like a function, to actually execute the side-effects.\n\nExample\n\njulia> using Reagents\n\njulia> reagent = Reagents.Return(1) ⨟ Reagents.Map(string);\n\njulia> reagent()\n\"1\"\n\n\n\n\n\n","category":"type"},{"location":"reference/api/","page":"API","title":"API","text":"Modules = [Reagents]\nFilter = t -> t isa Type && t <: Reagents.Reagent && t !== Reagents.Reagent","category":"page"},{"location":"reference/api/#Reagents.CAS","page":"API","title":"Reagents.CAS","text":"Reagents.CAS(ref::Reagents.Ref{T}, expected::T, desired::T)\n\nA reagent for replacing the value in ref from expected to desired. Multiple CAS reagents are committed atomically.\n\nExample\n\njulia> using Reagents\n\njulia> ref1 = Reagents.Ref(111);\n\njulia> ref2 = Reagents.Ref(222);\n\njulia> reagent = Reagents.CAS(ref1, 111, -1) ⨟ Reagents.CAS(ref2, 222, -2);\n\njulia> reagent();\n\njulia> ref1[]\n-1\n\njulia> ref2[]\n-2\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Computed","page":"API","title":"Reagents.Computed","text":"Reagents.Computed(f)\n\nCreate a reagent dynamically with function f which receives the output of the upstream reagent. The resulting reagent is composed with the downstream reagent.\n\nExamples\n\njulia> using Reagents\n       using Reagents: Read, CAS, Computed\n\njulia> ref = Reagents.Ref(0);\n\njulia> reagent = Read(ref) ⨟ Computed(old -> CAS(ref, old, old + 1));\n\njulia> reagent();\n\njulia> ref[]\n1\n\njulia> reagent();\n\njulia> ref[]\n2\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Identity","page":"API","title":"Reagents.Identity","text":"Reagents.Identity()\n\nThe identity reagent.  This is the identity element of ⨟ (hence of ∘).\n\nExamples\n\njulia> using Reagents\n\njulia> reagent = Reagents.Map(string) ⨟ Reagents.Identity();\n\njulia> reagent(111)\n\"111\"\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Map","page":"API","title":"Reagents.Map","text":"Reagents.Map(f)\n\nTransform the output value of the upstream reagent by f and pass it to the downstream reagent.\n\nExamples\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref(111);\n\njulia> (Reagents.Read(ref) ⨟ Reagents.Map(string))()\n\"111\"\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.PostCommit","page":"API","title":"Reagents.PostCommit","text":"Reagents.PostCommit(f)\n\nRun f(x) when the reagent successfully completed its reaction where x is the output of the upstream reagent.\n\nExamples\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref(111);\n\njulia> reagent = Reagents.Read(ref) ⨟ Reagents.PostCommit(x -> @show(x));\n\njulia> reagent();\nx = 111\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Read","page":"API","title":"Reagents.Read","text":"Reagents.Read(ref::Reagents.Ref)\n\nA reagent that reads the value in ref.\n\nExample\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref(111);\n\njulia> reagent = Reagents.Read(ref);\n\njulia> reagent()\n111\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Return","page":"API","title":"Reagents.Return","text":"Reagents.Return(value)\n\nPass value to the downstream reagent.\n\nExamples\n\njulia> using Reagents\n\njulia> Reagents.Return(1)()\n1\n\njulia> ref = Reagents.Ref(111);\n\njulia> (Reagents.Return(222) ⨟ Reagents.Update((old, inc) -> (old + inc, old), ref))()\n111\n\njulia> ref[]\n333\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Until","page":"API","title":"Reagents.Until","text":"Reagents.Until(f, loop::Reagent)\n\nKeep reacting with reagent while f returns nothing on the output of loop. The reaction of loop will be committed if f returns nothing but without the reaction of the reagent upstream to Until; i.e., they are still put on hold.  Once f returns non-nothing, the upstream reaction (from reagents before the loop), the reaction of the loop, and the downstream reactions are committed together, like other type of reagents.\n\nExamples\n\njulia> using Reagents\n\njulia> ref1 = Reagents.Ref(10);\n       ref2 = Reagents.Ref(111);\n\njulia> reagent = Reagents.Until(Reagents.Update((x, _) -> (x - 1, x), ref1)) do x\n           if x > 1\n               nothing\n           else\n               Some(x)\n           end\n       end ⨟ Reagents.Update((x, _) -> (x + 1, x), ref2);\n\njulia> reagent()\n111\n\njulia> ref1[]\n0\n\njulia> ref2[]\n112\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Update","page":"API","title":"Reagents.Update","text":"Reagents.Update(f, ref::Reagents.Ref{T})\n\nGiven a function of form (v::T, a) -> (w::T, b) and a Reagents.Ref holding a value of type T, update its value to w and pass the output b to the downstream reagent. The function f receives the value v in ref and the output of a of the upstream reagent.\n\nExample\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref(0);\n\njulia> add! = Reagents.Update((v, a) -> (v + a, v), ref);\n\njulia> add!(1)  # add 1 and return the old value\n0\n\njulia> add!(2)\n1\n\njulia> ref[]\n3\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.WithNack","page":"API","title":"Reagents.WithNack","text":"Reagents.WithNack(f)\n\nDynamically create a reagent with negative acknowledgement (nack) reagent.\n\nFunction f takes a reagent nack that is blocked until the reaction of this reagent is cancelled (i.e., another branch of | is selected). Function f must return a reagent.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/","page":"API","title":"API","text":"Reagents.channel","category":"page"},{"location":"reference/api/#Reagents.channel","page":"API","title":"Reagents.channel","text":"Reagents.channel(A::Type, B::Type = A) -> (a2b, b2a)\n\nCreate a pair of swap endpoints for exchanging a value a of type A and a value b of type B synchronously.\n\nThe endpoints a2b and b2a are reagents.\n\nExample\n\njulia> using Reagents\n\njulia> a2b, b2a = Reagents.channel(Int, Symbol);\n\njulia> t = @async b2a(:hello);\n\njulia> a2b(123)\n:hello\n\njulia> fetch(t)\n123\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Reagent-Combinators","page":"API","title":"Reagent Combinators","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"Reagents.:|\nReagents.:&\nReagents.:⨟","category":"page"},{"location":"reference/api/#Reagents.:|","page":"API","title":"Reagents.:|","text":"r1 | r2\n\nThe choice combinator. Invokes the reaction of one and exactly one reagent.  The choice is left-biased; i.e., r1 | r2 tries r1 first and then try r2.\n\nExample\n\njulia> using Reagents\n\njulia> ref1 = Reagents.Ref(111);\n\njulia> ref2 = Reagents.Ref(222);\n\njulia> r1 = Reagents.CAS(ref1, -1, 0);  # will fail (wrong expected old value)\n\njulia> r2 = Reagents.CAS(ref2, 222, 333);  # will succeed\n\njulia> (r1 | r2)();\n\njulia> ref1[]\n111\n\njulia> ref2[]\n333\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Reagents.:&","page":"API","title":"Reagents.:&","text":"r1 & r2\n\nThe pairing combinator. Both reagents r1 and r2 are executed and the downstream reagent receives the tuple (y1, y2) where y1 is the output of r1 and y2 is the output of r2.\n\nExample\n\njulia> using Reagents\n\njulia> ref1 = Reagents.Ref(111);\n\njulia> ref2 = Reagents.Ref(222);\n\njulia> r1 = Reagents.Read(ref1);\n\njulia> r2 = Reagents.Read(ref2);\n\njulia> (r1 & r2)()\n(111, 222)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#CompositionsBase.:⨟","page":"API","title":"CompositionsBase.:⨟","text":"r1 ⨟ r2\nr2 ∘ r1\nopcompose(r1, r2)\ncompose(r2, r1)\n\nThe operator ⨟ (\\bbsemi) sequences reagents. The composition r1 ⨟ r2 means to invoke r1 and also r2 with the output of r1. Note that the entire reaction is still done atomically.\n\nThe syntaxes r1 ⨟ r2 and r2 ∘ r1 are equivalent. It is recommended to use r1 ⨟ r2 to clarify the top-to-down data flow when the reagent definition spans multiple lines. However, knowing that r1 ⨟ r2 is equivalent to r2 ∘ r1  can be useful for remember that, in the reaction (r2 ∘ r1)(x), the reagent r1 is the one that sees the input x.\n\nopcompose and compose are ASCII aliases of ⨟ and ∘, respectively.\n\nExample\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref(111);\n\njulia> r1 = Reagents.Read(ref);\n\njulia> r2 = Reagents.Map(string);\n\njulia> (r1 ⨟ r2)()\n\"111\"\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Reaction-failures","page":"API","title":"Reaction failures","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"Reagents.Block\nReagents.Retry","category":"page"},{"location":"reference/api/#Reagents.Block","page":"API","title":"Reagents.Block","text":"Reagents.Block()\n\nA value indicating that the reaction is blocked.\n\nReagents such as Reagents.Computed and Reagents.Map can return this value to indicate that other branches of the choice combinator | should be used.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Retry","page":"API","title":"Reagents.Retry","text":"Reagents.Retry\n\nA value indicating that the reaction should be retried.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Misc","page":"API","title":"Misc","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"Modules = [Reagents]\nFilter = t -> !(\n    (t isa Type && t <: Union{Reagents.Reagent,Reagents.Failure}) ||\n    t isa Module ||\n    t in ((|), (&), (Reagents.:⨟), Reagents.channel)\n)","category":"page"},{"location":"reference/api/#Reagents.Ref","page":"API","title":"Reagents.Ref","text":"Reagents.Ref{T}()\nReagents.Ref{T}(value::T)\n\nCreate a reference storing a value of type T.\n\nUse reagents such as Reagents.Update, Reagents.CAS, and Reagents.Read to manipulate the value.\n\nExample\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref{Int}();\n\njulia> ref[] = 111;\n\njulia> ref[]\n111\n\njulia> Reagents.try(Reagents.CAS(ref, 111, 222)) !== nothing\ntrue\n\njulia> ref[]\n222\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.dissolve","page":"API","title":"Reagents.dissolve","text":"Reagents.dissolve(catalyst::Reagent)\n\nRegister catalyst as a persistent reagent that helps other reaction.\n\nThe reagent catalyst must include a blocking reagent (i.e., Reagents.channel).\n\nFor more information, see Catalysts section in the manual.\n\nExamples\n\njulia> using Reagents\n\njulia> send1, receive1 = Reagents.channel(Int, Nothing)\n       send2, receive2 = Reagents.channel(Char, Nothing)\n       sendall, receiveall = Reagents.channel(Tuple{Int,Char}, Nothing);\n\njulia> catalyst = (receive1 & receive2) ⨟ sendall;\n\njulia> Reagents.dissolve(catalyst);\n\njulia> @sync begin\n           @async send1(1)\n           @async send2('a')\n           receiveall()\n       end\n(1, 'a')\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Reagents.try","page":"API","title":"Reagents.try","text":"Reagents.try(reagent::Reagent, [value = nothing])\n\nInvoke reagent with value. If it succeeds with an output, return Some(output). If it is blocked, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"#Reagents.jl","page":"Reagents.jl","title":"Reagents.jl","text":"","category":"section"},{"location":"","page":"Reagents.jl","title":"Reagents.jl","text":"Main._BANNER_","category":"page"},{"location":"","page":"Reagents.jl","title":"Reagents.jl","text":"Reagents","category":"page"},{"location":"#Reagents","page":"Reagents.jl","title":"Reagents","text":"Reagents.jl: Towards composable and extensible nonblocking programming for Julia\n\n(Image: docs dev)\n\nReagents.jl implements reagents (Turon, 2012) which provides higher-order concurrency primitives for expressing nonblocking algorithms and concurrent synchronizations in a composable manner.\n\nFor example, op1 | op2 is the combinator that combines the \"lazy\" representation of operations (called reagents) and expresses that only one of the operations take place. This is similar to Go's select statement on channels (Ref: specification) but Reagents.jl has other combinators and is extensible to any user-defined data structures.\n\nNote: Due to the simplistic implementation of the k-CAS, Reagents.jl is not yet nonblocking in the strict sense.  However, as discussed in Turon (2012), it should be straightforward to switch to a k-CAS algorithm with more strict guarantee.\n\nExample: Treiber stack\n\nLet us implement Treiber stack which can be represented as an atomic reference to an immutable list:\n\nusing Reagents\n\nstruct Node{T}\n    head::T\n    tail::Union{Node{T},Nothing}\nend\n\nconst List{T} = Union{Node{T},Nothing}\n\nstruct TreiberStack{T,Ref<:Reagents.Ref{List{T}}}\n    head::Ref\nend\n\nTreiberStack{T}() where {T} = TreiberStack(Reagents.Ref{List{T}}(nothing))\nnothing\n# output\n\nThe push and pop operations can be expressed as reagents:\n\npushing(stack::TreiberStack) =\n    Reagents.Update((xs, x) -> (Node(x, xs), nothing), stack.head)\n\npopping(stack::TreiberStack) =\n    Reagents.Update(stack.head) do xs, _\n        if xs === nothing\n            return (nothing, nothing)\n        else\n            return (xs.tail, xs.head)\n        end\n    end\nnothing\n# output\n\nThe execution (\"reaction\") of the reagent can be invoked by just calling the reagent object.  So, it's straightforward to wrap it in the standard function API:\n\nBase.push!(stack::TreiberStack, value) = pushing(stack)(value)\nBase.pop!(stack::TreiberStack) = popping(stack)()\nnothing\n# output\n\nThese user-defined reagents can be composed just like pre-defined reagents. For example, we can move an element from one stack to another by using the sequencing combinator ⨟:\n\ns1 = TreiberStack{Int}()\ns2 = TreiberStack{Int}()\npush!(s1, 1)\n(popping(s1) ⨟ pushing(s2))()\n@assert pop!(s2) == 1\nnothing\n# output\n\nHere, the element in the stack s1 is popped and then pushed to the stack s2 atomically. Similar code works with arbitrary pair of containers, possibly of different types.\n\nFor more examples, read the documentation or see the examples directory.\n\nResources\n\nTuron, Aaron. 2012. “Reagents: Expressing and Composing Fine-Grained Concurrency.” In Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation, 157–168. PLDI ’12. New York, NY, USA: Association for Computing Machinery. https://doi.org/10.1145/2254064.2254084.\nThe original implementation by Turon (2012): https://github.com/aturon/ChemistrySet\nSivaramakrishnan, KC, and Théo Laurent. “Lock-Free Programming for the Masses,” https://kcsrk.info/papers/reagents_ocaml16.pdf\nLDN Functionals #8 KC Sivaramakrishnan: OCaml multicore and programming with Reagents - YouTube\nReagent implementation for OCaml: https://github.com/ocaml-multicore/reagents\n\n\n\n\n\n","category":"module"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"EditURL = \"https://github.com/tkf/Reagents.jl/blob/master/examples/cancellablecontainers.jl\"","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"note: Note\nReagents.jl is still work-in-progress.","category":"page"},{"location":"tutorials/cancellablecontainers/#ex-cancellablecontainers","page":"Cancellable containers","title":"How to create a cancellable blocking API","text":"","category":"section"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"using Reagents: Block, CAS, Computed, Map, Read, Reagents, Return","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"As demonstrated in the examples Treiber stack and Michael and Scott queue, reagents can be used for defining nonblocking data structures. However, reagents can also be used for constructing complex synchronization APIs.","category":"page"},{"location":"tutorials/cancellablecontainers/#ex-blockingcontainers","page":"Cancellable containers","title":"Blocking containers","text":"","category":"section"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"When a value is not available in a nonblocking container, it is very useful to wait (block) until the value is available (as in Base.Channel). Using Reagents.channel (which we use here like an unbuffered Base.Channel), we can mechanically transform a nonblocking concurrent data container to a waitable data structure.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"To this end, let us define a simple wrapper type that wraps an underlying nonblocking data collection (.data) and the channel (.send and .receive):","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"struct Blocking{T,Data,Send,Receive}\n    eltype::Val{T}\n    data::Data          # holds value of type T\n    send::Send          # swaps value::T -> nothing\n    receive::Receive    # swaps nothing -> value::T\nend\n\nfunction Blocking(data)\n    send, receive = Reagents.channel(eltype(data), Nothing)\n    return Blocking(Val(eltype(data)), data, send, receive)\nend\n\nBase.eltype(::Type{<:Blocking{T}}) where {T} = T","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"The idea is to try sending or receiving the item via the channel and \"then\" try to manipulate the data collection. We can do this atomically by using the choice reagent |. Note that the order of this operation is important. For example, when invoking putting(b), it tries b.send first and this \"attempt\" is still active even during putting(b.data). Since this attempt to b.send is atomically withdrawn when committing the reaction, the item is added to the data collection if and only if there is no other tasks invoking taking(b).","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"putting(b::Blocking) = b.send | putting(b.data)\ntaking(b::Blocking) = b.receive | taking(b.data)\n\nBase.put!(b::Blocking, x) = putting(b)(convert(eltype(b), x))\nBase.take!(b::Blocking) = taking(b)()","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"This Blocking wrapper can be used to extend existing nonblocking data structures such as Treiber stack and Michael and Scott queue that we have already defined.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"include(\"treiberstack.jl\")\ninclude(\"msqueue.jl\")","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"To this end, we need to transform trypopping and trypoppingfirst to a reagent that blocks when the item is not ready. This can be done by a simple helper reagent that blocks when the input is nothing:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"blocknothing() = Map(x -> x === nothing ? Block() : something(x))","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Then, it is straightforward to define the taking and putting functions required by the Blocking wrapper:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"putting(c::TreiberStack) = pushing(c)\ntaking(c::TreiberStack) = trypopping(c) ⨟ blocknothing()\n\nputting(c::MSQueue) = pushing(c)\ntaking(c::MSQueue) = trypoppingfirst(c) ⨟ blocknothing()","category":"page"},{"location":"tutorials/cancellablecontainers/#Test-blocking-containers","page":"Cancellable containers","title":"Test blocking containers","text":"","category":"section"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"using Test\n\nfunction test_put_take_queue()","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"When there are enough items in the data container, Blocking(MSQueue{Int}()) behaves like MSQueue{Int}():","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    items = Blocking(MSQueue{Int}())\n    put!(items, 111)\n    put!(items, 222)\n    @test take!(items) == 111\n    @test take!(items) == 222","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"However, when take! is invoked on an empty collection (which is enforced by the \"unfair scheduling\" yield(t)), it blocks until the corresponding put! is invoked:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    t = @task take!(items)\n    yield(t)\n    put!(items, 333)\n    @test fetch(t) === 333\nend","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"It works with TreiberStack, too:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"function test_put_take_stack()\n    items = Blocking(TreiberStack{Int}())\n    put!(items, 111)\n    put!(items, 222)\n    @test take!(items) == 222\n    @test take!(items) == 111\n\n    t = @task take!(items)\n    yield(t)\n    put!(items, 333)\n    @test fetch(t) === 333\nend","category":"page"},{"location":"tutorials/cancellablecontainers/#Generic-cancellable-operations","page":"Cancellable containers","title":"Generic cancellable operations","text":"","category":"section"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"It is often useful to cancel a blocking operation safely. This can be expressed quite naturally using reagents — we'll create a CancellationToken which can be composed with any blocking operation. The pattern is similar to the Go idiom of listening to a Done channel as one of the blocking operations in a select statement.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"First, let us define a singleton sentinel value for indicating a given reaction is cancelled:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"struct Cancelled end","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"To illustrate the idea, let us again use a Blocking(MSQueue{Int}()):","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"function test_cancellation_idea()\n    items = Blocking(MSQueue{Int}())","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"We use an additional channel for sending the cancellation signal:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    send, receive = Reagents.channel(Cancelled, Nothing)","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"The idea is to \"listen to\" the cancellation signal and then try to invoke a blocking reaction. If there is no cancellation signal, it behaves like the reagent without the cancellation:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    t = @task (receive | taking(items))()\n    yield(t)\n    put!(items, 111)\n    @test fetch(t) == 111","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"If the cancellation signal is fired before the corresponding put!, the result of the reaction is the sentinel Cancelled().","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    t = @task (receive | taking(items))()\n    yield(t)\n    send(Cancelled())\n    @test fetch(t) isa Cancelled\nend","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Note that the above idea is still hard to use directly, since send(Cancelled()) only triggers the reactions that are happening simultaneously. We can introduce a Reagents.Ref{Bool} to make the cancellation permanent.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Let us wrap this idea in a single object:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"struct CancellationToken\n    iscancelled::typeof(Reagents.Ref{Bool}())\n    send::typeof(Reagents.channel(Cancelled, Nothing)[1])\n    receive::typeof(Reagents.channel(Cancelled, Nothing)[2])\nend\n\nfunction CancellationToken()\n    iscancelled = Reagents.Ref{Bool}(false)\n    send, receive = Reagents.channel(Cancelled, Nothing)\n    return CancellationToken(iscancelled, send, receive)\nend","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"We can then transform an arbitrary reagent to a reagent that can be cancelled via a \"signal\" through CancellationToken (defined in cancel! below). The resulting reagent is the composition of three components: listener, checker, and the original reagent:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"function cancellable(reagent::Reagents.Reagent, token::CancellationToken)\n    listener = Return(nothing) ⨟ token.receive\n    checker = Read(token.iscancelled) ⨟ Map(x -> x ? Cancelled() : Block())\n    return listener | checker | reagent\nend","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"The listener reagent is essentially equivalent to the idea demonstrated above.  It is prefixed with the Return(nothing) reagent to make sure we always invoke the token.receive swap point with the valid input nothing.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"The checker reagent checks token.iscancelled; if it is already true, it ends the reaction with the value Cancelled().  Otherwise, it indicates that the next reagent should be tried by returning the Block failure value.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Finally, if both listener and checker are blocked, the original reagent is invoked. When this reagent is blocked, the first reagent between listener and reagent that is awaken determines the result value of this reaction.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"We can then use cancellable combinator to define a cancellable_take! function:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"cancellable_take!(b::Blocking, token::CancellationToken) = cancellable(taking(b), token)()","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"To cancel! a token, we first set iscancelled[]. This way, all future cancellable_take! returns Cancelled due to the checker reagent defined above. We then clear out any existing peers listening to the token.receive swap endpoint.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"function cancel!(token::CancellationToken)\n    token.iscancelled[] = true\n    while Reagents.try(token.send, Cancelled()) !== nothing\n    end\nend","category":"page"},{"location":"tutorials/cancellablecontainers/#Test-generic-cancellable-operations","page":"Cancellable containers","title":"Test generic cancellable operations","text":"","category":"section"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"function test_cancellation_token()\n    items = Blocking(MSQueue{Int}())\n    token = CancellationToken()","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Before cancellation, cancellable_take! works like normal take!:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    t = @task cancellable_take!(items, token)\n    yield(t)\n    put!(items, 111)\n    @test fetch(t) == 111","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Calling cancel!(token) cancels all cancellable_take!(items, token) calls that are already happening (waiting for an item) and also the calls happening after the cancellation.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    t = @task cancellable_take!(items, token)\n    yield(t)\n    cancel!(token)\n    @test fetch(t) isa Cancelled\n    @test cancellable_take!(items, token) isa Cancelled","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Note that the cancellation mechanism is introduced outside the Blocking container.  It is different from, e.g., cancelling put!(::Base.Channel) via closing the Base.Channel. Thus, the container itself still works:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    put!(items, 222)\n    @test take!(items) == 222\nend","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"This page was generated using Literate.jl.","category":"page"}]
}
