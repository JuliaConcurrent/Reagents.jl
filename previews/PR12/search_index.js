var documenterSearchIndex = {"docs":
[{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"EditURL = \"https://github.com/tkf/Reagents.jl/blob/master/examples/msqueue.jl\"","category":"page"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"note: Note\nReagents.jl is still work-in-progress.","category":"page"},{"location":"tutorials/msqueue/#ex-msqueue","page":"Michael and Scott queue","title":"Example: Michael and Scott queue","text":"","category":"section"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"WIP (TODO: add explanation)","category":"page"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"using Reagents\n\nstruct MSQNode{T,R}\n    next::R\n    data::T\n    # Node{T,R}() = new{T,R}()\n    MSQNode{T,R}(next) where {T,R} = new{T,R}(next)\n    MSQNode{T,R}(next, data) where {T,R} = new{T,R}(next, data)\nend\n\nconst MSQNodeRef{T} = Reagents.Ref{Union{Nothing,MSQNode{T}}}\nconst MSQHeadRef{T} = Reagents.Ref{MSQNode{T}}\n\nMSQNode(next::MSQNodeRef{T}) where {T} = MSQNode{T,typeof(next)}(next)\nMSQNode(next::MSQNodeRef{T}, data) where {T} = MSQNode{T,typeof(next)}(next, data)\n\nstruct MSQueue{T,R<:MSQHeadRef{T}}\n    head::R\n    tail::R\n    function MSQueue{T}() where {T}\n        node = MSQNode(MSQNodeRef{T}(nothing))\n        head = MSQHeadRef{T}(node)\n        tail = MSQHeadRef{T}(node)\n        return new{T,typeof(head)}(head, tail)\n    end\nend\n\nnodetype(::MSQueue{<:Any,R}) where {N,R<:Reagents.Ref{N}} = N\n\nBase.eltype(::Type{<:MSQueue{T}}) where {T} = T\n\ntrypoppingfirst(q::MSQueue{T}) where {T} =\n    Reagents.Update(q.head) do node, _\n        next = node.next[]\n        if next === nothing\n            (node, nothing)\n        else\n            next::nodetype(q)\n            (next, Some(next.data))\n        end\n    end\n\npushing(q::MSQueue{T}) where {T} =\n    Reagents.Computed() do x\n        node = MSQNode(MSQNodeRef{T}(nothing), x)\n        while true\n            tail = q.tail[]\n            tail::nodetype(q)\n            next = tail.next[]\n            if next === nothing  # found the tail\n                return Reagents.CAS(tail.next, nothing, node) ⨟ Reagents.PostCommit() do _\n                    Reagents.try(Reagents.CAS(q.tail, tail, node))\n                end\n            else  # need the fixup\n                next::nodetype(q)\n                Reagents.try(Reagents.CAS(q.tail, tail, next))\n            end\n        end\n    end\n\ntrypopfirst!(q::MSQueue) = trypoppingfirst(q)()\nBase.popfirst!(q::MSQueue) = something(trypopfirst!(q))\nBase.push!(q::MSQueue, x) = pushing(q)(convert(eltype(q), x))","category":"page"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"","category":"page"},{"location":"tutorials/msqueue/","page":"Michael and Scott queue","title":"Michael and Scott queue","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"EditURL = \"https://github.com/tkf/Reagents.jl/blob/master/examples/treiberstack.jl\"","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"note: Note\nReagents.jl is still work-in-progress.","category":"page"},{"location":"tutorials/treiberstack/#ex-treiberstack","page":"Treiber stack","title":"Example: Treiber stack","text":"","category":"section"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"using Reagents","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Treiber stack is a simple concurrent data structure where an immutable list holds the data items","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"struct TSNode{T}\n    head::T\n    tail::Union{TSNode{T},Nothing}\nend\n\nconst TSList{T} = Union{TSNode{T},Nothing}","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"... which is referenced through an atomically updatable memory location (here, a Reagents.Ref):","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"struct TreiberStack{T,Ref<:Reagents.Ref{TSList{T}}}\n    head::Ref\nend\n\nBase.eltype(::Type{<:TreiberStack{T}}) where {T} = T","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"An empty stack can be constructed as a reference to the empty list; i.e., nothing:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"TreiberStack{T}() where {T} = TreiberStack(Reagents.Ref{TSList{T}}(nothing))","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"To push an element to the stack, we can use Reagents.Update","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"pushing(stack::TreiberStack) =\n    Reagents.Update((xs, x) -> (TSNode(x, xs), nothing), stack.head)","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Let's see how it works.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"using Test\n\nfunction test_pushing()","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"When a stack is created, its head points to nothing:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    stack = TreiberStack{Int}()\n    @test stack.head[] === nothing  # empty","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"We can create a reagent for pushing a value to the stack:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    reagent = pushing(stack)","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"However, note that reagent does nothing when it's created.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    @test stack.head[] === nothing  # empty","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"The reagent must be executed (\"react\") to invoke its side-effect:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    reagent(111)\n    @test stack.head[] === TSNode(111, nothing)\nend","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Similarly, we can pop off an element from the stack, again by Reagents.Update. To support empty stack, we return nothing when it's empty and return Some(value) when we find a value:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"trypopping(stack::TreiberStack) =\n    Reagents.Update(stack.head) do xs, _ignored\n        if xs === nothing\n            return (nothing, nothing)\n        else\n            return (xs.tail, Some(xs.head))\n        end\n    end","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Here's how it works.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"function test_trypopping()","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Let's push 111 and then 222 using the pushing reagent:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    stack = TreiberStack{Int}()\n    pushing(stack)(111)\n    pushing(stack)(222)","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"We can invoke the reagent trypopping(stack) by calling it. Since trypopping ignores the input (see the argument _ignored in trypopping definition above), we can pass an arbitrary value to the reagent, e.g., nothing.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    @test trypopping(stack)(nothing) === Some(222)","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"For convinience, nothing is the default argument when the reagent is called without an argument:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    @test trypopping(stack)() === Some(111)","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Now that all values are popped, invoking trypopping returns nothing:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"    @test trypopping(stack)() === nothing\nend","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"It is simple to wrap these reagents into the Base API:","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Base.push!(stack::TreiberStack, value) = pushing(stack)(convert(eltype(stack), value))\nBase.pop!(stack::TreiberStack) = something(trypopping(stack)())","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"Note that this version of pop!(stack::TreiberStack) throws when the stack is empty.  See Blocking containers for a generic derivation of a blocking version of pop! that waits for the value to be push!ed.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"For more usage examples, see /test/ReagentsTests/src/test_treiberstack.jl.","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"","category":"page"},{"location":"tutorials/treiberstack/","page":"Treiber stack","title":"Treiber stack","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"reference/api/","page":"API","title":"API","text":"Main._BANNER_","category":"page"},{"location":"reference/api/","page":"API","title":"API","text":"Modules = [Reagents]\nOrder = [:type, :function]","category":"page"},{"location":"reference/api/#Reagents.CAS","page":"API","title":"Reagents.CAS","text":"Reagents.CAS(ref::Reagents.Ref{T}, expected::T, desired::T)\n\nA reagent for replacing the value in ref from expected to desired. Multiple CAS reagents are committed atomically.\n\nExample\n\njulia> using Reagents\n\njulia> ref1 = Reagents.Ref(111);\n\njulia> ref2 = Reagents.Ref(222);\n\njulia> reagent = Reagents.CAS(ref1, 111, -1) ⨟ Reagents.CAS(ref2, 222, -2);\n\njulia> reagent();\n\njulia> ref1[]\n-1\n\njulia> ref2[]\n-2\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.PostCommit","page":"API","title":"Reagents.PostCommit","text":"Reagents.PostCommit(f)\n\nRun f(output) when the reagent successfully completed its reaction with output.\n\nExamples\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref(111);\n\njulia> reagent = Reagents.Read(ref) ⨟ Reagents.PostCommit(x -> @show(x));\n\njulia> reagent();\nx = 111\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Read","page":"API","title":"Reagents.Read","text":"Reagents.Read(ref::Reagents.Ref)\n\nA reagent that reads the value in ref.\n\nExample\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref(111);\n\njulia> reagent = Reagents.Read(ref);\n\njulia> reagent()\n111\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Reagent","page":"API","title":"Reagents.Reagent","text":"Reagents.Reagent\n\nComposable description for nonblocking and synchronous operations.\n\nReagents can be composed with ∘ although it is recommended to use the opposite composition operator ⨟.  A composed Reagent can be called, just like a function, to actually execute the side-effects.\n\nExample\n\njulia> using Reagents\n\njulia> reagent = Reagents.Return(1) ⨟ Reagents.Map(string);\n\njulia> reagent()\n\"1\"\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Ref","page":"API","title":"Reagents.Ref","text":"Reagents.Ref{T}()\nReagents.Ref{T}(value::T)\n\nCreate a reference storing a value of type T.\n\nUse reagents such as Reagents.Update, Reagents.CAS, and Reagents.Read to manipulate\n\nExample\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref{Int}();\n\njulia> ref[] = 111;\n\njulia> ref[]\n111\n\njulia> Reagents.try(Reagents.CAS(ref, 111, 222)) !== nothing\ntrue\n\njulia> ref[]\n222\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#Reagents.Update","page":"API","title":"Reagents.Update","text":"Reagents.Update(f, ref::Reagents.Ref{T})\n\nGiven a function of form (v::T, a) -> (w::T, b) and a Reagents.Ref holding a value of type T, update its value to w and pass the output b to the downstream reagent. The function f receives the value v in ref and the output of a of the upstream reagent.\n\nExample\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref(0);\n\njulia> add! = Reagents.Update((v, a) -> (v + a, v), ref);\n\njulia> add!(1)  # add 1 and return the old value\n0\n\njulia> add!(2)\n1\n\njulia> ref[]\n3\n\n\n\n\n\n","category":"type"},{"location":"reference/api/#CompositionsBase.:⨟","page":"API","title":"CompositionsBase.:⨟","text":"r1 ⨟ r2\nr2 ∘ r1\n\nThe operator ⨟ (\\bbsemi) sequences reagents. The composition r1 ⨟ r2 means to invoke r1 and also r2 with the output of r1. Note that the entire reaction is still done atomically.\n\nThe syntaxes r1 ⨟ r2 and r2 ∘ r1 are equivalent. It is recommended to use r1 ⨟ r2 to clarify the top-to-down data flow when the reagent definition spans multiple lines. However, knowing that r1 ⨟ r2 is equivalent to r2 ∘ r1  can be useful for remember that, in the reaction (r2 ∘ r1)(x), the reagent r1 is the one that sees the input x.\n\nExample\n\njulia> using Reagents\n\njulia> ref = Reagents.Ref(111);\n\njulia> r1 = Reagents.Read(ref);\n\njulia> r2 = Reagents.Map(string);\n\njulia> (r1 ⨟ r2)()\n\"111\"\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Reagents.:&","page":"API","title":"Reagents.:&","text":"r1 & r2\n\nThe pairing combinator. Both reagents r1 and r2 are executed and the downstream reagent receives the tuple (y1, y2) where y1 is the output of r1 and y2 is the output of r2.\n\nExample\n\njulia> using Reagents\n\njulia> ref1 = Reagents.Ref(111);\n\njulia> ref2 = Reagents.Ref(222);\n\njulia> r1 = Reagents.Read(ref1);\n\njulia> r2 = Reagents.Read(ref2);\n\njulia> (r1 & r2)()\n(111, 222)\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Reagents.:|","page":"API","title":"Reagents.:|","text":"r1 | r2\n\nThe choice combinator. Invokes the reaction of one and exactly one reagent.  The choice is left-biased; i.e., r1 | r2 tries r1 first and then try r2.\n\nExample\n\njulia> using Reagents\n\njulia> ref1 = Reagents.Ref(111);\n\njulia> ref2 = Reagents.Ref(222);\n\njulia> r1 = Reagents.CAS(ref1, -1, 0);  # will fail (wrong expected old value)\n\njulia> r2 = Reagents.CAS(ref2, 222, 333);  # will succeed\n\njulia> (r1 | r2)();\n\njulia> ref1[]\n111\n\njulia> ref2[]\n333\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Reagents.channel","page":"API","title":"Reagents.channel","text":"Reagents.channel(A::Type, B::Type = A) -> (a2b, b2a)\n\nCreate a pair of swap endpoints for exchanging a value a of type A and a value b of type B synchronously.\n\nExample\n\njulia> using Reagents\n\njulia> a2b, b2a = Reagents.channel(Int, Symbol);\n\njulia> t = @async b2a(:hello);\n\njulia> a2b(123)\n:hello\n\njulia> fetch(t)\n123\n\n\n\n\n\n","category":"function"},{"location":"reference/api/#Reagents.try","page":"API","title":"Reagents.try","text":"Reagents.try(reagent::Reagent, [value = nothing])\n\nInvoke reagent with value. If it succeeds with an output, return Some(output). If it is blocked, return nothing.\n\n\n\n\n\n","category":"function"},{"location":"#Reagents.jl","page":"Reagents.jl","title":"Reagents.jl","text":"","category":"section"},{"location":"","page":"Reagents.jl","title":"Reagents.jl","text":"Main._BANNER_","category":"page"},{"location":"","page":"Reagents.jl","title":"Reagents.jl","text":"Reagents","category":"page"},{"location":"#Reagents","page":"Reagents.jl","title":"Reagents","text":"Reagents.jl: Towards composable and extensible nonblocking programming for Julia\n\nReagents.jl implements reagents (Turon, 2012) which provides higher-order concurrency primitives for expressing nonblocking algorithms and concurrent synchronizations in a composable manner.\n\nFor example, op1 | op2 is the combinator that combines the \"lazy\" representation of operations (called reagents) and expresses that only one of the operations take place. This is similar to Go's select statement on channels (Ref: specification) but Reagents.jl has other combinators and is extensible to any user-defined data structures.\n\nNote: Due to the simplistic implementation of the k-CAS, Reagents.jl is not yet nonblocking in the strict sense.  However, as discussed in Turon (2012), it should be straightforward to switch to a k-CAS algorithm with more strict guarantee.\n\nExample: Treiber stack\n\nLet us implement Treiber stack which can be represented as an atomic reference to an immutable list:\n\nusing Reagents\n\nstruct Node{T}\n    head::T\n    tail::Union{Node{T},Nothing}\nend\n\nconst List{T} = Union{Node{T},Nothing}\n\nstruct TreiberStack{T,Ref<:Reagents.Ref{List{T}}}\n    head::Ref\nend\n\nTreiberStack{T}() where {T} = TreiberStack(Reagents.Ref{List{T}}(nothing))\nnothing\n# output\n\nThe push and pop operations can be expressed as reagents:\n\npushing(stack::TreiberStack) =\n    Reagents.Update((xs, x) -> (Node(x, xs), nothing), stack.head)\n\npopping(stack::TreiberStack) =\n    Reagents.Update(stack.head) do xs, _\n        if xs === nothing\n            return (nothing, nothing)\n        else\n            return (xs.tail, xs.head)\n        end\n    end\nnothing\n# output\n\nThe execution (\"reaction\") of the reagent can be invoked by just calling the reagent object.  So, it's straightforward to wrap it in the standard function API:\n\nBase.push!(stack::TreiberStack, value) = pushing(stack)(value)\nBase.pop!(stack::TreiberStack) = popping(stack)()\nnothing\n# output\n\nThese user-defined reagents can be composed just like pre-defined reagents. For example, we can move an element from one stack to another by using the sequencing combinator ⨟:\n\ns1 = TreiberStack{Int}()\ns2 = TreiberStack{Int}()\npush!(s1, 1)\n(popping(s1) ⨟ pushing(s2))()\n@assert pop!(s2) == 1\nnothing\n# output\n\nHere, the element in the stack s1 is popped and then pushed to the stack s2 atomically. Similar code works with arbitrary pair of containers, possibly of different types.\n\nFor more examples, see the examples directory.\n\nResources\n\nTuron, Aaron. 2012. “Reagents: Expressing and Composing Fine-Grained Concurrency.” In Proceedings of the 33rd ACM SIGPLAN Conference on Programming Language Design and Implementation, 157–168. PLDI ’12. New York, NY, USA: Association for Computing Machinery. https://doi.org/10.1145/2254064.2254084.\nThe original implementation by Turon (2012): https://github.com/aturon/ChemistrySet\nSivaramakrishnan, KC, and Théo Laurent. “Lock-Free Programming for the Masses,” https://kcsrk.info/papers/reagents_ocaml16.pdf\nLDN Functionals #8 KC Sivaramakrishnan: OCaml multicore and programming with Reagents - YouTube\nReagent implementation for OCaml: https://github.com/ocaml-multicore/reagents\n\n\n\n\n\n","category":"module"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"EditURL = \"https://github.com/tkf/Reagents.jl/blob/master/examples/cancellablecontainers.jl\"","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"note: Note\nReagents.jl is still work-in-progress.","category":"page"},{"location":"tutorials/cancellablecontainers/#ex-cancellablecontainers","page":"Cancellable containers","title":"How to create a cancellable blocking API","text":"","category":"section"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"using Reagents: Block, CAS, Computed, Map, Read, Reagents, Return","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"As demonstrated in the examples Treiber stack and Michael and Scott queue, reagents can be used for defining nonblocking data structures. However, reagents can also be used for constructing complex synchronization APIs.","category":"page"},{"location":"tutorials/cancellablecontainers/#ex-blockingcontainers","page":"Cancellable containers","title":"Blocking containers","text":"","category":"section"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"When a value is not available in a nonblocking container, it is very useful to wait (block) until the value is available (as in Base.Channel). Using Reagents.channel (which is like unbuffered Base.Channel), we can mechanically transform a nonblocking data container to a waitable data structure.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"To this end, let us define a simple wrapper type that wraps underlying nonblocking data collection (.data) and the channel (.send and .receive):","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"struct Blocking{T,Data,Send,Receive}\n    eltype::Val{T}\n    data::Data          # holds value of type T\n    send::Send          # swaps value::T -> nothing\n    receive::Receive    # swaps nothing -> value::T\nend\n\nfunction Blocking(data)\n    send, receive = Reagents.channel(eltype(data), Nothing)\n    return Blocking(Val(eltype(data)), data, send, receive)\nend\n\nBase.eltype(::Type{<:Blocking{T}}) where {T} = T","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"The idea is to try sending or receiving the item via the channel and \"then\" try to manipulate the data collection. We can do this atomically by using the choice reagent |.  Note that the order of this operation is importnat. For example, when invoking putting(b), it tries b.send first and this \"attempt\" is still active even during putting(b.data). Since this attempt to b.send is atomically withdrawn when committing the reaction, the item is added to the data collection if and only if there is no other tasks invoking taking(b).","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"putting(b::Blocking) = b.send | putting(b.data)\ntaking(b::Blocking) = b.receive | taking(b.data)\n\nBase.put!(b::Blocking, x) = putting(b)(convert(eltype(b), x))\nBase.take!(b::Blocking) = taking(b)()","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"This Blocking wrapper can be used to extend existing nonblocking data structures such as Treiber stack and Michael and Scott queue that we have already defined.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"include(\"treiberstack.jl\")\ninclude(\"msqueue.jl\")","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"To this end, we need to transform trypopping and trypoppingfirst to a reagent that blocks when the item is not ready.  It can be done by this simple helper reagent that blocks when the input is nothing:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"blocknothing() = Map(x -> x === nothing ? Block() : something(x))","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Then, it is straightforward to define the API required for the Blocking wrapper:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"putting(c::TreiberStack) = pushing(c)\ntaking(c::TreiberStack) = trypopping(c) ⨟ blocknothing()\n\nputting(c::MSQueue) = pushing(c)\ntaking(c::MSQueue) = trypoppingfirst(c) ⨟ blocknothing()","category":"page"},{"location":"tutorials/cancellablecontainers/#Test-blocking-containers","page":"Cancellable containers","title":"Test blocking containers","text":"","category":"section"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"using Test\n\nfunction test_put_take_queue()","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"When there are enough items in the data container, Blocking(MSQueue{Int}()) behaves like MSQueue{Int}():","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    items = Blocking(MSQueue{Int}())\n    put!(items, 111)\n    put!(items, 222)\n    @test take!(items) == 111\n    @test take!(items) == 222","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"However, when take! is invoked on an empty collection (which is enforced by the \"unfair scheduling\" yield(::Task)), it blocks until the corresponding put! is invoked:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    t = @task take!(items)\n    yield(t)\n    put!(items, 333)\n    @test fetch(t) === 333\nend","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"It works with TreiberStack, too:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"function test_put_take_stack()\n    items = Blocking(TreiberStack{Int}())\n    put!(items, 111)\n    put!(items, 222)\n    @test take!(items) == 222\n    @test take!(items) == 111\n\n    t = @task take!(items)\n    yield(t)\n    put!(items, 333)\n    @test fetch(t) === 333\nend","category":"page"},{"location":"tutorials/cancellablecontainers/#Generic-cancellable-operations","page":"Cancellable containers","title":"Generic cancellable operations","text":"","category":"section"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"It is often useful to cancel blocking operation safely. It can be expressed by reagents quite naturally.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"First, let us define a singleton sentinel value for indicating a given reaction is cancelled:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"struct Cancelled end","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"To illustrate the idea, let us again use a Blocking(MSQueue{Int}()):","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"function test_cancellation_idea()\n    items = Blocking(MSQueue{Int}())","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"We use additonal channel for sending cancellation signal:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    send, receive = Reagents.channel(Cancelled, Nothing)","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"The idea is to \"listen to\" the cancellation signal and then try to invoke a blocking reaction. If there is no cancellation signal, it behaves like the reagent without the cancellation:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    t = @task (receive | taking(items))()\n    yield(t)\n    put!(items, 111)\n    @test fetch(t) == 111","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"If the cancellation signal is fired before the corresponding put!, the result of the reaction is the sentinel Cancelled().","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    t = @task (receive | taking(items))()\n    yield(t)\n    send(Cancelled())\n    @test fetch(t) isa Cancelled\nend","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Note that the above idea is still hard to use directly, since send(Cancelled()) only triggers the reactions that are happening simultaneously. We can introduce a Reagents.Ref{Bool} to make the cancellation permanent.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Let us wrap this idea in a single object:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"struct CancellationToken\n    iscancelled::typeof(Reagents.Ref{Bool}())\n    send::typeof(Reagents.channel(Cancelled, Nothing)[1])\n    receive::typeof(Reagents.channel(Cancelled, Nothing)[2])\nend\n\nfunction CancellationToken()\n    iscancelled = Reagents.Ref{Bool}(false)\n    send, receive = Reagents.channel(Cancelled, Nothing)\n    return CancellationToken(iscancelled, send, receive)\nend","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"We can then transform an arbitrary reagent to a reagent that can be cancelled via a \"signal\" through CancellationToken (defined in cancel! below). The resulting reagent is the compostion of three components: listener, checker, and the original reagent:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"function cancellable(reagent::Reagents.Reagent, token::CancellationToken)\n    listener = Return(nothing) ⨟ token.receive\n    checker = Read(token.iscancelled) ⨟ Map(x -> x ? Cancelled() : Block())\n    return listener | checker | reagent\nend","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"The listener reagent is essentially equivalent to the idea demonstrated above.  It is prefixed with the Return(nothing) reagent to make sure we always invoke the token.receive swap point with the valid input nothing.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"The checker reagent checks token.iscancelled; if it is already true, it ends the reaction with the value Cancelled().  Otherwise, it indicates that the next reagent should be tried by returning the Block failure value.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Finally, if both listener and checker are blocked, the original reagent is invoked. When this reagent is blocked, the first reagent between listener and reagent that is awaken determines the result value of this reaction.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"We can then use cancellable combinator to define a cancellable_take! function:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"cancellable_take!(b::Blocking, token::CancellationToken) = cancellable(taking(b), token)()","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"To fire the cancellation signal, we first set iscancelled[]. This way, all future cancellable_take! returns Cancelled due to the checker reagent defined above. We then clear out any existing peers listening to the toeken.receive swap endpoint.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"function cancel!(token::CancellationToken)\n    token.iscancelled[] = true\n    while Reagents.try(token.send, Cancelled()) !== nothing\n    end\nend","category":"page"},{"location":"tutorials/cancellablecontainers/#Test-generic-cancellable-operations","page":"Cancellable containers","title":"Test generic cancellable operations","text":"","category":"section"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"function test_cancellation_token()\n    items = Blocking(MSQueue{Int}())\n    token = CancellationToken()","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Before cancellation, cancellable_take! works like normal take!:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    t = @task cancellable_take!(items, token)\n    yield(t)\n    put!(items, 111)\n    @test fetch(t) == 111","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Calling cancel!(token) cancells all cancellable_take!(items, token) calls that are already happening (waiting for an item) and also the calls happening after the cancellation.","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    t = @task cancellable_take!(items, token)\n    yield(t)\n    cancel!(token)\n    @test fetch(t) isa Cancelled\n    @test cancellable_take!(items, token) isa Cancelled","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"Note that the cancellation mechanism is introduced outside the Blocking container.  It is different from, e.g., cancelling put!(::Base.Channel) via closing the Base.Channel. Thus, the container itself still works:","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"    put!(items, 222)\n    @test take!(items) == 222\nend","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"","category":"page"},{"location":"tutorials/cancellablecontainers/","page":"Cancellable containers","title":"Cancellable containers","text":"This page was generated using Literate.jl.","category":"page"}]
}
